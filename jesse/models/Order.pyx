from playhouse.postgres_ext import * 
import jesse.helpers as jh
import jesse.services.logger as logger
# import jesse.services.selectors as selectors
from jesse.config import config
from jesse.services.notifier import notify
from jesse.enums import order_statuses, order_submitted_via
from libc.math cimport NAN
# from libc.time cimport time,time_t
import random
import ruuid as uuid

# def uuid4():
  # return '%032x' % random.getrandbits(128)
# from jesse.services.db import database


# if database.is_closed():
    # database.open_connection()


class Order():
    # id generated by Jesse for database usage
    id = uuid.uuid4()
    trade_id = uuid.uuid4()
    session_id = uuid.uuid4()

    # id generated by market, used in live-trade mode
    exchange_id : str = None
    # some exchanges might require even further info
    vars : dict = None
    symbol: str 
    exchange : str 
    side : str 
    type : str 
    reduce_only = bool
    qty : float 
    filled_qty : float = 0
    price : float = NAN
    status : str =order_statuses.ACTIVE
    created_at : int = None
    executed_at : int = None
    canceled_at : int = None
    submitted_via = None

    class Meta:
        # database = database.db
        indexes = ((('trade_id', 'exchange', 'symbol', 'status', 'created_at'), False),)

    def __init__(self, attributes: dict = None, **kwargs) -> None:
        # Model.__init__(self, attributes=attributes, **kwargs)
        from jesse.store import store 
        
        if attributes is None:
            attributes = {}

        for a, value in attributes.items():
            setattr(self, a, value)

        if self.created_at is None:
            self.created_at = jh.now_to_timestamp()

        if jh.is_debuggable('order_submission') and (self.status == order_statuses.ACTIVE):
            txt = f'{"SUBMITTED"} order: {self.symbol}, {self.type}, {self.side}, {self.qty}'
            if self.price:
                txt += f', ${round(self.price, 2)}'
            logger.info(txt)

        # handle exchange balance for ordered asset
        e = store.exchanges.storage.get(self.exchange, None)
        e.on_order_submission(self)

    @property
    def is_queued(self) -> bool:
        """
        Used in live mode only: it means the strategy has considered the order as submitted,
        but the exchange does not accept it because of the distance between the current
        price and price of the order. Hence it's been queued for later submission.
        :return: bool
        """
        return self.status == order_statuses.QUEUED
        
    @property
    def is_cancellable(self):
        """
        orders that are either active or partially filled
        """
        return self.status == order_statuses.ACTIVE or self.is_partially_filled
        
    @property
    def is_canceled(self) -> bool:
        return self.status == order_statuses.CANCELED

    @property
    def is_active(self) -> bool:
        return self.status == order_statuses.ACTIVE

    @property
    def is_new(self) -> bool:
        return self.status == order_statuses.ACTIVE

    @property
    def is_executed(self) -> bool:
        return self.status == order_statuses.EXECUTED

    @property
    def is_filled(self) -> bool:
        return self.is_executed

    @property
    def is_partially_filled(self) -> bool:
        return self.status == order_statuses.PARTIALLY_FILLED
        
    @property
    def is_stop_loss(self):
        return self.submitted_via == order_submitted_via.STOP_LOSS

    @property
    def is_take_profit(self):
        return self.submitted_via == order_submitted_via.TAKE_PROFIT
        
    @property
    def to_dict(self):
        return {
            'id': self.id,
            'session_id': self.session_id,
            'exchange_id': self.exchange_id,
            'symbol': self.symbol,
            'side': self.side,
            'type': self.type,
            'qty': self.qty,
            'filled_qty': self.filled_qty,
            'price': self.price,
            'status': self.status,
            'created_at': self.created_at,
            'canceled_at': self.canceled_at,
            'executed_at': self.executed_at,
        }

    @property
    def position(self):
        from jesse.store import store 
        key = (f'{exchange}-{symbol}')
        return store.positions.storage.get(key, None)
        
    @property
    def remaining_qty(self) -> float:
        return jh.prepare_qty(abs(self.qty) - abs(self.filled_qty), self.side)
        
    @property
    def value(self) -> float:
        return abs(self.qty) * self.price
        
    def cancel(self, silent=False, source='') -> None:
        from jesse.store import store 
        if self.status == order_statuses.CANCELED or self.status == order_statuses.EXECUTED:
            return
            
        self.canceled_at = jh.now_to_timestamp()
        self.status = order_statuses.CANCELED

        if not silent:
            txt = f'CANCELED order: {self.symbol}, {self.type}, {self.side}, {self.qty}'
            if self.price:
                txt += f', ${round(self.price, 2)}'
            if jh.is_debuggable('order_cancellation'):
                logger.info(txt)

        # handle exchange balance
        e = store.exchanges.storage.get(self.exchange, None)
        e.on_order_cancellation(self)

        
    def execute(self, silent=False) -> None:
        if self.status == order_statuses.CANCELED or self.status == order_statuses.EXECUTED:
            return
            
        from jesse.store import store 

        self.executed_at = jh.now_to_timestamp()
        self.status = order_statuses.EXECUTED

        # if not silent:
            # txt = f'EXECUTED order: {self.symbol}, {self.type}, {self.side}, {self.qty}'
            # if self.price:
                # txt += f', ${round(self.price, 2)}'
            # log
            # if jh.is_debuggable('order_execution'):
                # logger.info(txt)
        key = f'{self.exchange}-{self.symbol}' 
        
        # if not silent:
            # txt = f'EXECUTED order: {self.symbol}, {self.type}, {self.side}, {self.qty}'
            # if self.price:
                # txt += f', ${round(self.price, 2)}'
            # log
            # if jh.is_debuggable('order_execution'):
                # logger.info(txt)
        #from jesse.store import store
        store.completed_trades.add_executed_order(self)
       

        # handle exchange balance for ordered asset
        e = store.exchanges.storage.get(self.exchange, None)
        e.on_order_execution(self)

        p = store.positions.storage.get(key, None)
        if p:
            p._on_executed_order(self)
            
    def execute_partially(self, silent=False) -> None:
        self.executed_at = jh.now_to_timestamp()
        self.status = order_statuses.PARTIALLY_FILLED

        if not silent:
            txt = f"PARTIALLY FILLED: {self.symbol}, {self.type}, {self.side}, filled qty: {self.filled_qty}, remaining qty: {self.remaining_qty}, price: {self.price}"
            # log
            if jh.is_debuggable('order_execution'):
                logger.info(txt)


        # log the order of the trade for metrics
        from jesse.store import store
        store.completed_trades.add_executed_order(self)
        key = f'{self.exchange}-{self.symbol}' 
        p = store.positions.storage.get(key, None)

        if p:
            p._on_executed_order(self)
            
# if database is open, create the table
# if database.is_open():
    # Order.create_table()
